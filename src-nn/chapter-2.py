import math

'''
Дана ФМП: f(x1, x2)= x1^2 + 4x1 + x2^2 - 2x2 + 10. Найдите ее частные производные (их 2 штуки). Приравняйте обе производные к нулю и решите полученную систему уравнений. Ее решение и будет точкой минимума (мамой клянусь, что не максимума).
В ответ напишите значение переменной x1 в точке минимума.

f'(x1) = 2x1 + 4
f'(x2) = 2x2 - 2

2x1 + 4 = 0
x1 = -2

2x2 - 2 = 0
x2 = 1
'''

'''
Система уравнений из прошлой задачи решалась легко.
А теперь вот такая функция: f(x1, x2) = x1^2 + 4x1 + 2x2^2 + 5x2 + 3x1*x2 + 6 и у нее действительно есть точка минимума.
Найдите ее и в ответ напишите координату точки минимума по второй переменной.

f'(x1) = 2x1 + 4 + 3x2
f'(x2) = 4x2 + 5 + 3x1

2x1 + 4 + 3x2 = 0
4x2 + 5 + 3x1 = 0

2x1 + 4 + 3x2 = 0
3x1 + 5 + 4x2 = 0

6x1 + 12 + 9x2 = 0
6x1 + 10 + 8x2 = 0

6x1 + 12 + 9x2 = 6x1 + 10 + 8x2
x2 = -2

2x1 + 4 - 6 = 0
-8 + 5 + 3x1 = 0

x1 = 1
x1 = 1
'''

'''
А это задачка просто на навыки дифференцирования. Дана функция f(x1,x2)= sin(x1*x2), слабо найти ее частные производные?
Напишите в ответ, чему равно значение частной производной по второму аргументу в точке  (1, 0).

f'(x2) = cos(x1*x2)
cos(1*0) = 1

'''


'''
А это еще задачка просто на навыки дифференцирования. Дана функция f(x1, x2, x3) = ln(x1*x2 + x1*x3), слабо найти ее частные производные?
Напишите в ответ, чему равно значение частной производной по первому аргументу в точке  (4,2,1).

(u(v))' = u'(v) * v'
f' = 1/(x1*x2 + x1*x3) * (x2 + x3) = 1/12 * 3 = 0.25


Точки минимума многих переменных
a1 := a0 - h * f'(a0)

Модификация с шагом h
h[n+1] = h[0] - (1 - n/T)
T итераций - константа

Пусть f(x)=x^2, a0=1, h=1, тогда следующей точкой спуска будет a1=-1 , а потом будет a2=1 - то есть градиентный спуск вернётся к первоначальной позиции (проверьте это сами!). Иными словами, градиентный спуск «зациклится" и на следующих шагах мы уже никогда не приблизимся к точке минимума x=0. Мы будем лишь колебаться между точками -1 и 1.
Что делать?
А нужно применить одну из модификаций градиентного спуска, связанной с изменением шага h. Итак, возьмем формулу h = h0 * (1 - n/T) для h0=1, T=4.
Это означает, что возникнет следующая последовательность шагов: 1, 0.75, 0.5, 0.25, 0.
Кроме того, после пятого шага спуска шаг станет равным 0 и процесс самопроизвольно остановится. В общем, у вас есть 5 шагов, чтобы подойти к точке минимума.
Давайте вычислять позиции "шарика" после каждого шага. Поскольку вначале шаг равен 1, то (как и ранее) мы получим a1=-1. А вот дальше начинаются различия.
Найдите позиции шарика a2, a3, не забывайте, что в первом случае вы должны использовать шаг h=0.75, а во втором случае h=0.5.
В ответ запишите точку a3.
'''

def fnStep1(h, T, step):
    hList = [h]
    for i in range(1, step):
        hNew = round(h * (1 - i/T), 2)
        hList.append(hNew)
    return hList

def fnStep2(h, T, step):
    hList = [h]
    for i in range(1, step):
        hNew = round(h * math.exp(-1*i/T), 2)
        hList.append(hNew)
    return hList

def fn2(a):
    return 2 * a

def stepMod(a, h, T, step, fnStep, fn):
    hList = fnStep(h, T, step)

    for i in range(step):
        print(f'a[{i}]={a} h={hList[i]}')
        a = round(a - hList[i] * fn(a), 2)
        print(f'a[{i+1}]={a}')

    print(f'final a[{step-1}]={a}\n\n')

'''
Мы снова помучаем функцию  f(x1, x2)=x1^2 + 10x2^2. Ранее мы выяснили, что при a0=(10,1), h=0.1 значения второй координаты нашего "шарика" будут прыгать между 1 и -1.  При этом значения по первой координате очень медленно подбираются к нулю.
Ваш выход, метод Adagrad! Как было сказано на видео-лекции, Adagrad способен настроить разную величину шага по каждой из координат. В нашем случае нам необходимо, чтобы шаг по первой координате увеличивался, а по второй координате - уменьшался.
Посмотрим, что получится у Адского Града! Сделаем два шага этого метода и получим точки a1, a2. В дальнейших расчетах полагаем (epsilon)ε=0.
В ответе напишите, чему равна первая координата точки a2.

f = x1^2 + 10x2^2
f'x1 = 2*x1
f'x2 = 20*x2
delta f = (2*x1, 20*x2)

a0=(10, 1)
dlt f = (20, 20)
G1 = (400, 400)
a1 := (10, 1) - (0.1/sqr(400, 400)) * (20, 20) = (10, 1) - 0.1 = (9.9, 0.9)

a1=(9.9, 0.9)
dlt f = (19.8, 19.8)
G2 = (392.04, 392.04) + (400, 400) = (792.04, 792.04)
a2 = (9.9, 0.9) - (0.1/sqr(792.04, 792.04)) * (19.8, 19.8) = (9.9, 0.9) - (0.1/(28.14, 28.14)) * (19.8, 19.8) =
(9.9, 0.9) - (0.1 * (0.7, 0.7)) = (9.83, 0.83)
'''

'''
Мы снова помучаем функцию  f(x1, x2) = x1^2 + 10x2^2. Ранее мы выяснили, что при  a0 = (10, 1), h = 0.1 значения второй координаты нашего "шарика" будут прыгать между 1 и -1.  При этом значения по первой координате очень медленно подбираются к нулю.
Как ускорить спуск по первой координате и одновременно избежать зацикливания по второй координате?
Посмотрим, что сделает метод Adam!  В дальнейших расчетах полагаем epsilon = 0, beta1 = beta2 = 0.9
В ответе напишите, чему равна первая координата точки a2.
'''

def main():
    stepMod(1, 1, 4, 5, fnStep1, fn2)
    stepMod(1, 1, 1, 5, fnStep2, fn2)

if __name__ == '__main__':
    main()